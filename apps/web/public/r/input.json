{
  "name": "input",
  "type": "registry:ui",
  "description": "A text input field with validation, keyboard filtering, and file validation",
  "platform": "web",
  "dependencies": [
    "class-variance-authority",
    "lucide-react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "ui/input/input.tsx",
      "type": "registry:ui",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport { Upload } from \"lucide-react\";\nimport { cn } from \"../../lib/utils\";\nimport {\n  validateValue,\n  validateFile,\n  characterPresets,\n  isControlKey,\n  formatFileSize,\n  type ValidationResult,\n} from \"./validation\";\n\n// ---------------------------------------------------------------------------\n// Variants\n// ---------------------------------------------------------------------------\n\nconst inputVariants = cva(\n  \"flex w-full rounded-md border border-input bg-background px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50\",\n  {\n    variants: {\n      size: {\n        sm: \"h-9 px-3 text-sm\",\n        md: \"h-10 px-3 py-2 text-sm\",\n        lg: \"h-11 px-4 text-base\",\n      },\n    },\n    defaultVariants: {\n      size: \"md\",\n    },\n  }\n);\n\n// ---------------------------------------------------------------------------\n// Types\n// ---------------------------------------------------------------------------\n\nexport interface InputProps\n  extends\n    Omit<React.InputHTMLAttributes<HTMLInputElement>, \"size\">,\n    VariantProps<typeof inputVariants> {\n  // --- Validation ---\n  /** Enable built-in validation based on `type` (email / tel / number) */\n  validate?: boolean;\n  /** Custom regex pattern for validation (overrides type-based pattern) */\n  validationPattern?: RegExp;\n  /** Custom error message (overrides default Farsi message) */\n  validationMessage?: string;\n  /** Callback fired when validation state changes */\n  onValidationChange?: (result: {\n    isValid: boolean;\n    message?: string;\n  }) => void;\n\n  // --- Keyboard Restriction ---\n  /** Restrict which characters can be typed */\n  allowedCharacters?:\n    | RegExp\n    | \"digits\"\n    | \"alpha\"\n    | \"alphanumeric\"\n    | \"persian\";\n  /** Enhanced max length with character count feedback */\n  maxInputLength?: number;\n\n  // --- File Validation (type=\"file\") ---\n  /** Maximum file size in bytes */\n  maxFileSize?: number;\n  /** Accepted file extensions, e.g. [\".pdf\", \".png\"] */\n  acceptFormats?: string[];\n\n  // --- Error Display ---\n  /** Show inline error message below the input (default: false) */\n  showError?: boolean;\n}\n\n// ---------------------------------------------------------------------------\n// Input Component\n// ---------------------------------------------------------------------------\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  (\n    {\n      className,\n      size,\n      type,\n      validate: shouldValidate,\n      validationPattern,\n      validationMessage,\n      onValidationChange,\n      allowedCharacters,\n      maxInputLength,\n      maxFileSize,\n      acceptFormats,\n      showError = false,\n      ...props\n    },\n    ref\n  ) => {\n    // ---- File Input ----\n    if (type === \"file\") {\n      return (\n        <FileInput\n          className={className}\n          size={size}\n          maxFileSize={maxFileSize}\n          acceptFormats={acceptFormats}\n          showError={showError}\n          onValidationChange={onValidationChange}\n          validationMessage={validationMessage}\n          ref={ref}\n          {...props}\n        />\n      );\n    }\n\n    // ---- Standard Input ----\n    return (\n      <StandardInput\n        className={className}\n        size={size}\n        type={type}\n        shouldValidate={shouldValidate}\n        validationPattern={validationPattern}\n        validationMessage={validationMessage}\n        onValidationChange={onValidationChange}\n        allowedCharacters={allowedCharacters}\n        maxInputLength={maxInputLength}\n        showError={showError}\n        ref={ref}\n        {...props}\n      />\n    );\n  }\n);\nInput.displayName = \"Input\";\n\n// ---------------------------------------------------------------------------\n// StandardInput (internal)\n// ---------------------------------------------------------------------------\n\ninterface StandardInputInternalProps\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"size\"\n  > {\n  size?: InputProps[\"size\"];\n  shouldValidate?: boolean;\n  validationPattern?: RegExp;\n  validationMessage?: string;\n  onValidationChange?: InputProps[\"onValidationChange\"];\n  allowedCharacters?: InputProps[\"allowedCharacters\"];\n  maxInputLength?: number;\n  showError?: boolean;\n}\n\nconst StandardInput = React.forwardRef<\n  HTMLInputElement,\n  StandardInputInternalProps\n>(\n  (\n    {\n      className,\n      size,\n      type,\n      shouldValidate,\n      validationPattern,\n      validationMessage,\n      onValidationChange,\n      allowedCharacters,\n      maxInputLength,\n      showError = false,\n      onBlur,\n      onKeyDown,\n      onChange,\n      ...props\n    },\n    ref\n  ) => {\n    const [error, setError] = React.useState<string | null>(null);\n    const [charCount, setCharCount] = React.useState(0);\n\n    // ---- Validation on blur ----\n    const handleBlur = React.useCallback(\n      (e: React.FocusEvent<HTMLInputElement>) => {\n        if (shouldValidate || validationPattern) {\n          const result = validateValue(e.target.value, {\n            type,\n            required: props.required,\n            pattern: validationPattern,\n            customMessage: validationMessage,\n          });\n          setError(result.isValid ? null : (result.message ?? null));\n          onValidationChange?.(result);\n        }\n        onBlur?.(e);\n      },\n      [\n        shouldValidate,\n        validationPattern,\n        validationMessage,\n        type,\n        props.required,\n        onValidationChange,\n        onBlur,\n      ]\n    );\n\n    // ---- Keyboard filtering ----\n    const handleKeyDown = React.useCallback(\n      (e: React.KeyboardEvent<HTMLInputElement>) => {\n        if (allowedCharacters && !isControlKey(e)) {\n          const charPattern =\n            typeof allowedCharacters === \"string\"\n              ? characterPresets[allowedCharacters]\n              : allowedCharacters;\n\n          if (charPattern && !charPattern.test(e.key)) {\n            e.preventDefault();\n          }\n        }\n        onKeyDown?.(e);\n      },\n      [allowedCharacters, onKeyDown]\n    );\n\n    // ---- Change handler (char count + re-validate if already errored) ----\n    const handleChange = React.useCallback(\n      (e: React.ChangeEvent<HTMLInputElement>) => {\n        if (maxInputLength !== undefined) {\n          setCharCount(e.target.value.length);\n        }\n\n        // Clear error on valid input after previous error\n        if (error && (shouldValidate || validationPattern)) {\n          const result = validateValue(e.target.value, {\n            type,\n            required: props.required,\n            pattern: validationPattern,\n            customMessage: validationMessage,\n          });\n          if (result.isValid) {\n            setError(null);\n            onValidationChange?.(result);\n          }\n        }\n\n        onChange?.(e);\n      },\n      [\n        maxInputLength,\n        error,\n        shouldValidate,\n        validationPattern,\n        validationMessage,\n        type,\n        props.required,\n        onValidationChange,\n        onChange,\n      ]\n    );\n\n    const hasError = error !== null;\n\n    return (\n      <div className=\"w-full\">\n        <input\n          type={type}\n          className={cn(\n            inputVariants({ size, className }),\n            hasError &&\n              \"border-destructive focus-visible:ring-destructive\"\n          )}\n          ref={ref}\n          maxLength={maxInputLength}\n          aria-invalid={hasError || undefined}\n          onBlur={handleBlur}\n          onKeyDown={handleKeyDown}\n          onChange={handleChange}\n          {...props}\n        />\n        {/* Character count */}\n        {maxInputLength !== undefined && (\n          <div className=\"flex justify-end mt-1\">\n            <span\n              className={cn(\n                \"text-xs text-muted-foreground\",\n                charCount >= maxInputLength && \"text-destructive\"\n              )}\n            >\n              {charCount}/{maxInputLength}\n            </span>\n          </div>\n        )}\n        {/* Inline error */}\n        {showError && hasError && (\n          <p className=\"text-sm text-destructive mt-1\" role=\"alert\">\n            {error}\n          </p>\n        )}\n      </div>\n    );\n  }\n);\nStandardInput.displayName = \"StandardInput\";\n\n// ---------------------------------------------------------------------------\n// FileInput (internal)\n// ---------------------------------------------------------------------------\n\ninterface FileInputInternalProps\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"size\" | \"type\"\n  > {\n  size?: InputProps[\"size\"];\n  maxFileSize?: number;\n  acceptFormats?: string[];\n  showError?: boolean;\n  onValidationChange?: InputProps[\"onValidationChange\"];\n  validationMessage?: string;\n}\n\nconst FileInput = React.forwardRef<HTMLInputElement, FileInputInternalProps>(\n  (\n    {\n      className,\n      size,\n      maxFileSize,\n      acceptFormats,\n      showError = false,\n      onValidationChange,\n      validationMessage,\n      onChange,\n      ...props\n    },\n    ref\n  ) => {\n    const [fileName, setFileName] = React.useState<string>(\"\");\n    const [error, setError] = React.useState<string | null>(null);\n    const inputRef = React.useRef<HTMLInputElement>(null);\n\n    React.useImperativeHandle(ref, () => inputRef.current!);\n\n    const handleFileChange = React.useCallback(\n      (e: React.ChangeEvent<HTMLInputElement>) => {\n        const file = e.target.files?.[0];\n\n        if (file) {\n          // Validate file\n          if (maxFileSize || acceptFormats) {\n            const result = validateFile(file, { maxFileSize, acceptFormats });\n            if (!result.isValid) {\n              const msg = validationMessage || result.message || null;\n              setError(msg);\n              setFileName(\"\");\n              onValidationChange?.({\n                isValid: false,\n                message: msg ?? undefined,\n              });\n              // Reset the input so the same file can be re-selected\n              e.target.value = \"\";\n              return;\n            }\n          }\n\n          setFileName(file.name);\n          setError(null);\n          onValidationChange?.({ isValid: true });\n        } else {\n          setFileName(\"\");\n          setError(null);\n        }\n\n        onChange?.(e);\n      },\n      [maxFileSize, acceptFormats, validationMessage, onValidationChange, onChange]\n    );\n\n    const hasError = error !== null;\n\n    // Build accept string from acceptFormats\n    const acceptAttr =\n      props.accept || (acceptFormats ? acceptFormats.join(\",\") : undefined);\n\n    return (\n      <div className=\"w-full\">\n        <div\n          className={cn(\n            inputVariants({ size, className }),\n            \"flex items-center gap-2 cursor-pointer\",\n            hasError && \"border-destructive focus-visible:ring-destructive\",\n            props.disabled && \"cursor-not-allowed opacity-50\"\n          )}\n          onClick={() => !props.disabled && inputRef.current?.click()}\n        >\n          <button\n            type=\"button\"\n            disabled={props.disabled}\n            className={cn(\n              \"flex items-center gap-2 rounded-sm bg-secondary px-2 py-0.5 text-xs font-medium text-secondary-foreground transition-colors\",\n              \"hover:bg-secondary/80 focus:outline-none\",\n              props.disabled && \"pointer-events-none\"\n            )}\n            tabIndex={-1}\n          >\n            <Upload className=\"h-3 w-3\" />\n            <span>انتخاب فایل</span>\n          </button>\n          <span\n            className={cn(\n              \"text-muted-foreground truncate flex-1 text-right text-xs\",\n              !fileName && \"opacity-70\"\n            )}\n            dir=\"rtl\"\n          >\n            {fileName || props.placeholder || \"فایلی انتخاب نشده\"}\n          </span>\n          <input\n            type=\"file\"\n            className=\"hidden\"\n            ref={inputRef}\n            accept={acceptAttr}\n            onChange={handleFileChange}\n            {...props}\n          />\n        </div>\n        {/* File constraints hint */}\n        {(maxFileSize || acceptFormats) && !hasError && (\n          <p className=\"text-xs text-muted-foreground mt-1\" dir=\"rtl\">\n            {[\n              maxFileSize\n                ? `حداکثر حجم: ${formatFileSize(maxFileSize)}`\n                : null,\n              acceptFormats\n                ? `فرمت‌های مجاز: ${acceptFormats.join(\"، \")}`\n                : null,\n            ]\n              .filter(Boolean)\n              .join(\" · \")}\n          </p>\n        )}\n        {/* Inline error */}\n        {showError && hasError && (\n          <p className=\"text-sm text-destructive mt-1\" role=\"alert\" dir=\"rtl\">\n            {error}\n          </p>\n        )}\n      </div>\n    );\n  }\n);\nFileInput.displayName = \"FileInput\";\n\n// ---------------------------------------------------------------------------\n// Exports\n// ---------------------------------------------------------------------------\n\nexport { Input, inputVariants };\n"
    },
    {
      "path": "ui/input/validation.ts",
      "type": "registry:ui",
      "content": "// ---------------------------------------------------------------------------\n// Validation Patterns\n// ---------------------------------------------------------------------------\n\nexport const validationPatterns = {\n  email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  tel: /^\\+?[0-9\\s\\-()]{7,15}$/,\n  iranianTel: /^(\\+98|0)?9\\d{9}$/,\n  number: /^-?\\d*\\.?\\d+$/,\n} as const;\n\n// ---------------------------------------------------------------------------\n// Character Presets (for keyboard filtering)\n// ---------------------------------------------------------------------------\n\nexport const characterPresets: Record<string, RegExp> = {\n  digits: /^[0-9]$/,\n  alpha: /^[a-zA-Z\\u0600-\\u06FF\\s]$/,\n  alphanumeric: /^[a-zA-Z0-9\\u0600-\\u06FF\\s]$/,\n  persian: /^[\\u0600-\\u06FF\\u200C\\u200F0-9\\s.,;:!?()«»؟،؛]$/,\n};\n\n// ---------------------------------------------------------------------------\n// Control Keys (should never be blocked by character filtering)\n// ---------------------------------------------------------------------------\n\nconst CONTROL_KEYS = new Set([\n  \"Backspace\",\n  \"Delete\",\n  \"Tab\",\n  \"Escape\",\n  \"Enter\",\n  \"ArrowLeft\",\n  \"ArrowRight\",\n  \"ArrowUp\",\n  \"ArrowDown\",\n  \"Home\",\n  \"End\",\n]);\n\nexport function isControlKey(e: React.KeyboardEvent): boolean {\n  return CONTROL_KEYS.has(e.key) || e.ctrlKey || e.metaKey || e.altKey;\n}\n\n// ---------------------------------------------------------------------------\n// Default Farsi Error Messages\n// ---------------------------------------------------------------------------\n\nexport const defaultMessages = {\n  email: \"لطفاً یک آدرس ایمیل معتبر وارد کنید.\",\n  tel: \"لطفاً یک شماره تلفن معتبر وارد کنید.\",\n  number: \"لطفاً یک عدد معتبر وارد کنید.\",\n  required: \"این فیلد الزامی است.\",\n  patternMismatch: \"مقدار وارد شده معتبر نیست.\",\n  fileTooLarge: (max: string) => `حجم فایل نباید بیشتر از ${max} باشد.`,\n  invalidFormat: (formats: string) => `فرمت‌های مجاز: ${formats}`,\n  minLength: (min: number) => `حداقل ${min} کاراکتر وارد کنید.`,\n  maxLength: (max: number) => `حداکثر ${max} کاراکتر مجاز است.`,\n} as const;\n\n// ---------------------------------------------------------------------------\n// File Size Formatter (bytes → readable Farsi string)\n// ---------------------------------------------------------------------------\n\nexport function formatFileSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes} بایت`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} کیلوبایت`;\n  if (bytes < 1024 * 1024 * 1024)\n    return `${(bytes / (1024 * 1024)).toFixed(1)} مگابایت`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} گیگابایت`;\n}\n\n// ---------------------------------------------------------------------------\n// validateValue – Pure validation function\n// ---------------------------------------------------------------------------\n\nexport interface ValidateValueOptions {\n  type?: string;\n  required?: boolean;\n  pattern?: RegExp;\n  minLength?: number;\n  maxLength?: number;\n  customMessage?: string;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  message?: string;\n}\n\nexport function validateValue(\n  value: string,\n  options: ValidateValueOptions = {}\n): ValidationResult {\n  const { type, required, pattern, minLength, maxLength, customMessage } =\n    options;\n\n  // Required check\n  if (required && !value.trim()) {\n    return { isValid: false, message: defaultMessages.required };\n  }\n\n  // Skip further validation if empty and not required\n  if (!value.trim()) {\n    return { isValid: true };\n  }\n\n  // Min length\n  if (minLength !== undefined && value.length < minLength) {\n    return {\n      isValid: false,\n      message: defaultMessages.minLength(minLength),\n    };\n  }\n\n  // Max length\n  if (maxLength !== undefined && value.length > maxLength) {\n    return {\n      isValid: false,\n      message: defaultMessages.maxLength(maxLength),\n    };\n  }\n\n  // Custom pattern\n  if (pattern) {\n    if (!pattern.test(value)) {\n      return {\n        isValid: false,\n        message: customMessage || defaultMessages.patternMismatch,\n      };\n    }\n    return { isValid: true };\n  }\n\n  // Type-based validation\n  switch (type) {\n    case \"email\":\n      if (!validationPatterns.email.test(value)) {\n        return {\n          isValid: false,\n          message: customMessage || defaultMessages.email,\n        };\n      }\n      break;\n    case \"tel\":\n      if (!validationPatterns.tel.test(value)) {\n        return {\n          isValid: false,\n          message: customMessage || defaultMessages.tel,\n        };\n      }\n      break;\n    case \"number\":\n      if (!validationPatterns.number.test(value)) {\n        return {\n          isValid: false,\n          message: customMessage || defaultMessages.number,\n        };\n      }\n      break;\n  }\n\n  return { isValid: true };\n}\n\n// ---------------------------------------------------------------------------\n// File Validation\n// ---------------------------------------------------------------------------\n\nexport interface FileValidationOptions {\n  maxFileSize?: number;\n  acceptFormats?: string[];\n}\n\nexport function validateFile(\n  file: File,\n  options: FileValidationOptions\n): ValidationResult {\n  const { maxFileSize, acceptFormats } = options;\n\n  if (maxFileSize && file.size > maxFileSize) {\n    return {\n      isValid: false,\n      message: defaultMessages.fileTooLarge(formatFileSize(maxFileSize)),\n    };\n  }\n\n  if (acceptFormats && acceptFormats.length > 0) {\n    const fileName = file.name.toLowerCase();\n    const hasValidFormat = acceptFormats.some((format) =>\n      fileName.endsWith(format.toLowerCase())\n    );\n    if (!hasValidFormat) {\n      return {\n        isValid: false,\n        message: defaultMessages.invalidFormat(acceptFormats.join(\"، \")),\n      };\n    }\n  }\n\n  return { isValid: true };\n}\n"
    }
  ],
  "utils": {
    "path": "lib/utils.ts",
    "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n"
  }
}